package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"text/template"
)

type Config struct {
	TagType string
	Output  string
}

type Generator struct {
	config   Config
	fset     *token.FileSet
	structs  map[string]*StructInfo // 当前包的结构体缓存
	allFiles []*ast.File            // 存储所有解析的文件
}

type StructInfo struct {
	Name   string
	Fields []FieldInfo
}

type FieldInfo struct {
	Name       string
	AccessPath string // 字段访问路径 (e.g. "Other.Money")
	IsPtr      bool
	Tag        string
}

func NewGenerator(config Config) *Generator {
	return &Generator{
		config:   config,
		fset:     token.NewFileSet(),
		structs:  make(map[string]*StructInfo),
		allFiles: make([]*ast.File, 0),
	}
}

func (g *Generator) ProcessFiles(filenames []string) error {
	// 第一轮：解析所有文件并存储AST
	for _, filename := range filenames {
		if err := g.parseAndStoreFile(filename); err != nil {
			return err
		}
	}

	// 第二轮：缓存所有结构体信息
	for _, file := range g.allFiles {
		g.cacheStructsFromFile(file)
	}

	// 第三轮：处理匿名字段，现在所有结构体都已经缓存了
	for _, info := range g.structs {
		g.resolveEmbeddedFields(info)
	}

	// 第四轮：生成代码文件
	for _, filename := range filenames {
		if err := g.generateFile(filename); err != nil {
			return err
		}
	}
	return nil
}

func (g *Generator) parseAndStoreFile(filename string) error {
	file, err := parser.ParseFile(g.fset, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}
	g.allFiles = append(g.allFiles, file)
	return nil
}

func (g *Generator) cacheStructsFromFile(file *ast.File) {
	ast.Inspect(file, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			return true
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			// 缓存结构体信息（先不处理匿名字段）
			info := &StructInfo{
				Name:   typeSpec.Name.Name,
				Fields: []FieldInfo{},
			}
			g.structs[typeSpec.Name.Name] = info

			// 收集字段信息（不处理匿名字段的嵌套）
			for _, field := range structType.Fields.List {
				g.processFieldBasic(field, info, "")
			}
		}
		return true
	})
}

func (g *Generator) processFieldBasic(field *ast.Field, info *StructInfo, prefix string) {
	fieldType := field.Type
	isPtr := false

	// 处理指针类型
	if starExpr, ok := fieldType.(*ast.StarExpr); ok {
		fieldType = starExpr.X
		isPtr = true
	}

	// 处理匿名字段（只记录类型名，稍后解析）
	if ident, ok := fieldType.(*ast.Ident); ok && len(field.Names) == 0 {
		// 添加一个标记字段，表示这是一个匿名字段
		info.Fields = append(info.Fields, FieldInfo{
			Name:       ident.Name, // 使用类型名作为临时标识
			AccessPath: ident.Name, // 匿名字段的访问路径就是类型名
			IsPtr:      isPtr,
			Tag:        "**EMBEDDED**", // 特殊标记表示这是匿名字段
		})
		return
	}

	// 处理普通字段
	for _, name := range field.Names {
		if !ast.IsExported(name.Name) {
			continue
		}

		tag := ""
		if field.Tag != nil {
			tag = reflect.StructTag(strings.Trim(field.Tag.Value, "`")).Get(g.config.TagType)
		}

		accessPath := name.Name
		if prefix != "" {
			accessPath = prefix + "." + accessPath
		}

		info.Fields = append(info.Fields, FieldInfo{
			Name:       name.Name,
			AccessPath: accessPath,
			IsPtr:      isPtr,
			Tag:        tag,
		})
	}
}

func (g *Generator) resolveEmbeddedFields(info *StructInfo) {
	var resolvedFields []FieldInfo
	var embeddedFields []FieldInfo

	// 先收集普通字段和嵌入字段
	for _, field := range info.Fields {
		if field.Tag == "**EMBEDDED**" {
			// 这是一个匿名字段，需要展开
			if embeddedStruct, exists := g.structs[field.Name]; exists {
				// 确保嵌入的结构体也已经解析了其匿名字段
				g.resolveEmbeddedFields(embeddedStruct)

				// 添加嵌入结构体的所有字段
				for _, embeddedField := range embeddedStruct.Fields {
					if embeddedField.Tag == "**EMBEDDED**" {
						continue // 跳过未解析的匿名字段
					}

					newField := FieldInfo{
						Name:       embeddedField.Name,
						AccessPath: field.AccessPath + "." + embeddedField.AccessPath,
						IsPtr:      embeddedField.IsPtr,
						Tag:        embeddedField.Tag,
					}
					embeddedFields = append(embeddedFields, newField)
				}
			}
		} else {
			// 普通字段，直接添加
			resolvedFields = append(resolvedFields, field)
		}
	}

	// 先添加嵌入字段，再添加普通字段（保证顶层字段优先）
	allFields := append(embeddedFields, resolvedFields...)
	info.Fields = allFields
}

func (g *Generator) generateFile(filename string) error {
	file, err := parser.ParseFile(g.fset, filename, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	var outputContent strings.Builder
	outputContent.WriteString("// Code generated by atgen. DO NOT EDIT.\n\n")
	outputContent.WriteString("package " + file.Name.Name + "\n")

	ast.Inspect(file, func(n ast.Node) bool {
		genDecl, ok := n.(*ast.GenDecl)
		if !ok || genDecl.Tok != token.TYPE {
			return true
		}

		// 检查是否有go:generate注释
		if genDecl.Doc == nil {
			return true
		}

		hasGenerate := false
		for _, comment := range genDecl.Doc.List {
			if strings.Contains(comment.Text, "//go:generate") {
				hasGenerate = true
				break
			}
		}

		if !hasGenerate {
			return true
		}

		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			structInfo, exists := g.structs[typeSpec.Name.Name]
			if !exists {
				continue
			}

			// 生成At方法
			outputContent.WriteString(g.generateAtMethod(structInfo))
		}
		return true
	})

	outputFile := g.config.Output
	if outputFile == "" {
		base := filepath.Base(filename)
		outputFile = strings.TrimSuffix(base, ".go") + "_at_gen.go"
	}

	return os.WriteFile(outputFile, []byte(outputContent.String()), 0644)
}

func (g *Generator) generateAtMethod(info *StructInfo) string {
	// 使用map来记录key的使用情况，避免重复
	keyToField := make(map[string]FieldInfo)
	duplicateWarnings := make([]string, 0)

	// 遍历所有字段，收集key映射关系
	for _, field := range info.Fields {
		if field.Tag == "**EMBEDDED**" {
			continue // 跳过未解析的匿名字段标记
		}

		key := strings.ToLower(field.Name)
		if g.config.TagType != "" && field.Tag != "" {
			// 处理标签中的逗号分隔选项（如 `json:"name,omitempty"`）
			tagValue := strings.Split(field.Tag, ",")[0]
			if tagValue != "" && tagValue != "-" {
				key = tagValue
			}
		}

		// 检查key是否已经存在
		if existingField, exists := keyToField[key]; exists {
			// 记录警告信息
			warning := fmt.Sprintf("\033[33mWARNING\033[0m: Key %q is duplicated.  Field %q (path: %s) ==> %q (path: %s)",
				key, field.Name, field.AccessPath, existingField.Name, existingField.AccessPath)
			duplicateWarnings = append(duplicateWarnings, warning)
		}

		// 使用最后遇到的字段（覆盖之前的）
		keyToField[key] = field
	}

	// 输出警告信息
	for _, warning := range duplicateWarnings {
		fmt.Fprintf(os.Stderr, "%s\n", warning)
	}

	// 生成case语句
	var cases strings.Builder
	for key, field := range keyToField {
		returnExpr := "&t." + field.AccessPath

		cases.WriteString(fmt.Sprintf(
			"\tcase %q:\n\t\treturn %s\n",
			key,
			returnExpr,
		))
	}

	const methodTmpl = `
func (t *{{.Name}}) At(key string) any {
	switch key {
{{.Cases}}	default:
		return nil
	}
}
`

	tmpl, err := template.New("method").Parse(methodTmpl)
	if err != nil {
		log.Fatalf("Error parsing template: %v", err)
	}

	var result strings.Builder
	data := struct {
		Name  string
		Cases string
	}{
		Name:  info.Name,
		Cases: cases.String(),
	}

	if err := tmpl.Execute(&result, data); err != nil {
		log.Fatalf("Error executing template: %v", err)
	}

	return result.String()
}
