package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

type Generator struct {
	typeName string
	keyType  string
	pkgPath  string
	pkg      *packages.Package
	imports  map[string]string // track required imports and their aliases
	file     *ast.File         // current file
}

func NewGenerator(typeName, keyType, pkgPath string) *Generator {
	return &Generator{
		typeName: typeName,
		keyType:  keyType,
		pkgPath:  pkgPath,
		imports:  make(map[string]string),
	}
}

func (gen *Generator) Generate(outputFile string) error {
	gen.logVerbose("starting code generation, type: %s, key type: %s, output file: %s", gen.typeName, gen.keyType, outputFile)

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedImports,
		Dir:  ".", // current directory
	}
	pkgs, err := packages.Load(cfg, gen.pkgPath)
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return fmt.Errorf("package %s not found", gen.pkgPath)
	}
	gen.pkg = pkgs[0]
	gen.logVerbose("loaded package successfully: %s (path: %s)", gen.pkg.Name, gen.pkg.PkgPath)

	// Find file containing struct definition
	file, structType, embeddedStructs, err := gen.findStructType()
	if err != nil {
		return err
	}
	gen.file = file
	gen.logVerbose("found struct: %s", gen.typeName)

	// Collect imports from package files
	gen.collectImportsFromFile()
	gen.logVerbose("collected imports:")
	for importPath, alias := range gen.imports {
		gen.logVerbose("  - %s -> %s", importPath, alias)
	}

	code, err := gen.generateAtMethod(structType, embeddedStructs)
	if err != nil {
		return err
	}

	// Create file and add imports
	f := jen.NewFile(gen.pkg.Name)

	// Add protective comment
	f.HeaderComment(
		fmt.Sprintf("Code generated by \"atgen -type=%s -key=%s -output=%s\"; DO NOT EDIT.", gen.typeName, gen.keyType, outputFile))

	if len(gen.imports) > 0 {
		f.Line()
	}

	f.Add(code)
	gen.logVerbose("saving file: %s", outputFile)
	return f.Save(outputFile)
}

// logVerbose prints formatted log message only in verbose mode
func (gen *Generator) logVerbose(format string, v ...any) {
	logVerbose(format, v...)
}

// Collect all imports from current package files
func (gen *Generator) collectImportsFromFile() {
	for _, file := range gen.pkg.Syntax {
		for _, imp := range file.Imports {
			path := strings.Trim(imp.Path.Value, `"`)

			var alias string
			if imp.Name != nil {
				alias = imp.Name.Name
			} else {
				parts := strings.Split(path, "/")
				alias = parts[len(parts)-1]
			}
			gen.imports[path] = alias
		}
	}
}

// Find file containing struct definition
func (gen *Generator) findStructType() (*ast.File, *ast.StructType, []*ast.StructType, error) {
	for _, file := range gen.pkg.Syntax {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != gen.typeName {
					continue
				}
				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					return nil, nil, nil, fmt.Errorf("%s is not a struct", gen.typeName)
				}
				embeddedStructs, err := gen.findEmbeddedStructs(structType)
				if err != nil {
					return nil, nil, nil, err
				}
				return file, structType, embeddedStructs, nil
			}
		}
	}
	return nil, nil, nil, fmt.Errorf("(findStructType) struct %s not found", gen.typeName)
}

func (gen *Generator) findEmbeddedStructs(structType *ast.StructType) ([]*ast.StructType, error) {
	var allEmbeddedStructs []*ast.StructType
	queue := []*ast.StructType{structType}
	for len(queue) > 0 {
		current := queue[0]
		queue = queue[1:]
		for _, field := range current.Fields.List {
			if len(field.Names) != 0 {
				continue
			}
			embeddedTypeName := gen.getEmbeddedTypeName(field)
			embeddedStruct, err := gen.findStructByName(embeddedTypeName)
			if err != nil {
				return nil, err
			}
			if embeddedStruct != nil {
				allEmbeddedStructs = append(allEmbeddedStructs, embeddedStruct)
				queue = append(queue, embeddedStruct)
			}
		}
	}

	return allEmbeddedStructs, nil
}

func (gen *Generator) getEmbeddedTypeName(field *ast.Field) string {
	switch expr := field.Type.(type) {
	case *ast.Ident:
		return expr.Name
	case *ast.StarExpr:
		if ident, ok := expr.X.(*ast.Ident); ok {
			return ident.Name
		}
	case *ast.SelectorExpr:
		// Handle nested selector expressions like pkg.Type.SubType
		if ident, ok := expr.X.(*ast.Ident); ok {
			return ident.Name + "." + expr.Sel.Name
		} else if sel, ok := expr.X.(*ast.SelectorExpr); ok {
			// Recursively handle nested selectors
			base := gen.getEmbeddedTypeName(&ast.Field{Type: sel})
			return base + "." + expr.Sel.Name
		}
	}
	return ""
}

func (gen *Generator) findStructByName(typeName string) (*ast.StructType, error) {
	// Handle types from other packages
	if strings.Contains(typeName, ".") {
		return nil, fmt.Errorf("cross-package embedded struct %s is not supported", typeName)
	}

	for _, file := range gen.pkg.Syntax {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}
			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != typeName {
					continue
				}
				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					return structType, nil
				}
			}
		}
	}
	return nil, fmt.Errorf("struct %s not found in package %s", typeName, gen.pkg.Name)
}

func (gen *Generator) generateAtMethodComment() *jen.Statement {
	return jen.Comment("At updates a field in " + gen.typeName + " by key using a visit callback function.").Line().
		Comment("").Line().
		Comment("Parameters:").Line().
		Comment("  - key: field identifier (either tag value or lowercase field name)").Line().
		Comment("  - visit: callback function that receives the current field value and returns a new value").Line().
		Comment("").Line().
		Comment("Returns:").Line().
		Comment("  - error: if the field is not found or if the new value has an incompatible type").Line().
		Comment("").Line().
		Comment("Note:").Line().
		Comment("  - If the visit function returns nil, no assignment is performed.").Line().
		Comment("  - To explicitly set a field to nil, use a different approach as nil is used").Line().
		Comment("    to indicate that no update should be performed.").Line().
		Comment("  - The method performs type checking to ensure type safety when assigning new values.").Line()
}

func (gen *Generator) generateAtMethod(structType *ast.StructType, embeddedStructs []*ast.StructType) (*jen.Statement, error) {
	// Add required imports
	if _, exists := gen.imports["fmt"]; !exists {
		gen.imports["fmt"] = "fmt"
	}

	method := gen.generateAtMethodComment().
		Func().
		Params(jen.Id("s").Op("*").Id(gen.typeName)).
		Id("At").
		Params(
			jen.Id("key").String(),
			jen.Id("visit").Func().Params(jen.Id("val").Any()).Any(),
		).
		Error().
		Block(
			jen.Switch(jen.Id("key")).BlockFunc(func(group *jen.Group) {
				processedKeys := make(map[string]bool)
				// Process main struct fields first to allow field shadowing:
				// if embedded struct and main struct have same field name, main struct takes precedence
				gen.processStructFields(group, structType, "s", processedKeys)
				// Process embedded structs to support composition
				for _, embeddedStruct := range embeddedStructs {
					gen.processStructFields(group, embeddedStruct, "s", processedKeys)
				}
				group.Default().Block(
					jen.Return(jen.Qual("fmt", "Errorf").Call(jen.Lit("field not found: %s"), jen.Id("key"))),
				)
			}),
			jen.Return(jen.Nil()),
		)

	return method, nil
}

// processStructFields iterates fields of structType and delegates per-field handling to processField
func (gen *Generator) processStructFields(group *jen.Group, structType *ast.StructType, receiver string, processedKeys map[string]bool) {
	for _, field := range structType.Fields.List {
		// Skip embedded fields here (they were handled separately)
		if len(field.Names) == 0 {
			continue
		}
		gen.processField(group, field, receiver, processedKeys)
	}
}

// processField handles generation for a single named field
func (gen *Generator) processField(group *jen.Group, field *ast.Field, receiver string, processedKeys map[string]bool) {
	// Safety: field must have a name
	if len(field.Names) == 0 {
		return
	}
	fieldName := field.Names[0].Name
	key := gen.getFieldKey(field, fieldName)

	// Skip duplicates
	if processedKeys[key] {
		return
	}
	processedKeys[key] = true

	// 1) build jen type node
	fieldTypeNode := gen.getFieldType(field.Type)

	// 2) render type node to string to inspect if it's interface{}
	fieldTypeStr := gen.renderFieldType(fieldTypeNode)

	// 3) emit switch case
	group.Case(jen.Lit(key))

	// 4) add assignment/type-assert logic
	gen.addAssignmentBlock(group, fieldName, fieldTypeNode, fieldTypeStr, receiver)
}

// renderFieldType renders a jen.Statement to string; returns "any" if rendering fails
func (gen *Generator) renderFieldType(stmt *jen.Statement) string {
	buf := new(bytes.Buffer)
	if err := stmt.Render(buf); err != nil {
		gen.logVerbose("warning: failed to parse field type rendering: %v", err)
		return "any"
	}
	return buf.String()
}

// addAssignmentBlock generates type-check and assignment logic depending on field type
func (gen *Generator) addAssignmentBlock(group *jen.Group, fieldName string, fieldTypeNode *jen.Statement, fieldTypeStr string, receiver string) {
	group.If(
		jen.Id("visitResult").Op(":=").Id("visit").Call(jen.Id(receiver).Dot(fieldName)),
		jen.Id("visitResult").Op("!=").Nil()).BlockFunc(func(ifGroup *jen.Group,
	) {
		// if field is interface{} or any, assign directly
		if fieldTypeStr == "interface{}" || fieldTypeStr == "any" {
			ifGroup.Id(receiver).Dot(fieldName).Op("=").Id("visitResult")
			return
		}
		ifGroup.If(
			jen.List(jen.Id("newVal"), jen.Id("ok")).Op(":=").Id("visitResult").Assert(fieldTypeNode),
			jen.Id("ok"),
		).Block(
			jen.Id(receiver).Dot(fieldName).Op("=").Id("newVal"),
			jen.Return(jen.Nil()),
		)

		ifGroup.Return(jen.Qual("fmt", "Errorf").Call(
			jen.Lit("type assertion failed for field %s: expected %s, got %T"),
			jen.Id("key"),
			jen.Lit(fieldTypeStr),
			jen.Id("visitResult"),
		))
	})
}

// getFieldType converts an ast.Expr into a jen.Statement for code generation
func (gen *Generator) getFieldType(expr ast.Expr) *jen.Statement {
	switch t := expr.(type) {
	case *ast.Ident:
		// Local type (current package), use Ident directly
		return jen.Id(t.Name)

	case *ast.StarExpr:
		// Pointer type: *T, process inner type recursively
		return jen.Op("*").Add(gen.getFieldType(t.X))

	case *ast.ArrayType:
		// Slice type: []T (simplified, ignores fixed-length arrays)
		return jen.Index().Add(gen.getFieldType(t.Elt))

	case *ast.MapType:
		// Map type: map[K]V, process Key and Value types separately
		return jen.Map(gen.getFieldType(t.Key)).Add(gen.getFieldType(t.Value))
	case *ast.SelectorExpr:
		if xIdent, ok := t.X.(*ast.Ident); ok {
			for path, alias := range gen.imports {
				if alias == xIdent.Name {
					return jen.Qual(path, t.Sel.Name)
				}
			}
		}
		// Fallback: use Any for unsupported cross-package types
		gen.logVerbose("warning: complex selector expression %v not fully supported", t)
		return jen.Any()
	case *ast.InterfaceType:
		// Interface type: interface{}
		return jen.Interface()

	case *ast.StructType:
		// Anonymous struct: struct{}
		return jen.Struct()

	default:
		gen.logVerbose("warning: unknown type %T, using any", t)
		return jen.Any()
	}
}

func (gen *Generator) getFieldKey(field *ast.Field, fieldName string) string {
	// If key type is specified (json/yaml/xml), use corresponding tag first
	if gen.keyType != "field" && field.Tag != nil {
		tag := strings.Trim(field.Tag.Value, "`")
		tagValue := extractTagValue(tag, gen.keyType)

		// Handle cases like `json:",omitempty"`
		if tagValue == "," {
			return strings.ToLower(fieldName)
		}
		parts := strings.SplitN(tagValue, ",", 2)
		if parts[0] != "" {
			return parts[0]
		}
	}

	// Use lowercase field name if no specified tag found
	return strings.ToLower(fieldName)
}

// Extract value for specified key from tag string
func extractTagValue(tag, key string) string {
	st := reflect.StructTag(strings.Trim(tag, "`"))
	return st.Get(key)
}
