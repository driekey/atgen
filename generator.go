package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/token"
	"reflect"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

type Generator struct {
	typeName string
	keyType  string
	pkgPath  string
	pkg      *packages.Package
	imports  map[string]string // track required imports and their aliases
	file     *ast.File         // current file
}

func NewGenerator(typeName, keyType, pkgPath string) *Generator {
	return &Generator{
		typeName: typeName,
		keyType:  keyType,
		pkgPath:  pkgPath,
		imports:  make(map[string]string),
	}
}

func (gen *Generator) Generate(outputFile string) error {
	gen.logVerbose("starting code generation, type: %s, key type: %s, output file: %s", gen.typeName, gen.keyType, outputFile)

	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedImports,
		Dir:  ".", // current directory
	}
	pkgs, err := packages.Load(cfg, gen.pkgPath)
	if err != nil {
		return err
	}

	if len(pkgs) == 0 {
		return fmt.Errorf("package %s not found", gen.pkgPath)
	}
	gen.pkg = pkgs[0]
	gen.logVerbose("loaded package successfully: %s (path: %s)", gen.pkg.Name, gen.pkg.PkgPath)

	// Find file containing struct definition
	file, structType, embeddedStructs, err := gen.findStructType()
	if err != nil {
		return err
	}
	gen.file = file
	gen.logVerbose("found struct: %s", gen.typeName)

	// Collect all imports from current file first
	gen.collectImportsFromFile()
	gen.logVerbose("collected imports:")
	for importPath, alias := range gen.imports {
		gen.logVerbose("  - %s -> %s", importPath, alias)
	}

	code, err := gen.generateAtMethod(structType, embeddedStructs)
	if err != nil {
		return err
	}

	// Create file and add imports
	f := jen.NewFile(gen.pkg.Name)

	// Add protective comment
	f.HeaderComment(
		fmt.Sprintf("Code generated by \"atgen -type=%s -key=%s -output=%s\"; DO NOT EDIT.", gen.typeName, gen.keyType, outputFile))

	if len(gen.imports) > 0 { // Add blank line if there are imports (format optimization)
		f.Line()
	}

	f.Add(code)
	gen.logVerbose("saving file: %s", outputFile)
	return f.Save(outputFile)
}

// logVerbose prints formatted log message only in verbose mode
func (gen *Generator) logVerbose(format string, v ...any) {
	logVerbose(format, v...)
}

// Collect all imports from current file
func (gen *Generator) collectImportsFromFile() {
	for _, file := range gen.pkg.Syntax {
		for _, imp := range file.Imports {
			path := strings.Trim(imp.Path.Value, `"`)
			var alias string
			if imp.Name != nil {
				alias = imp.Name.Name
			} else {
				// Use last part of path as identifier if no alias
				parts := strings.Split(path, "/")
				alias = parts[len(parts)-1]
			}
			gen.imports[path] = alias
		}
	}
}

// Find file containing struct definition
func (gen *Generator) findStructType() (*ast.File, *ast.StructType, []*ast.StructType, error) {
	for _, file := range gen.pkg.Syntax {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != gen.typeName {
					continue
				}

				structType, ok := typeSpec.Type.(*ast.StructType)
				if !ok {
					return nil, nil, nil, fmt.Errorf("%s is not a struct", gen.typeName)
				}

				// Find embedded structs
				embeddedStructs, err := gen.findEmbeddedStructs(structType)
				if err != nil {
					return nil, nil, nil, err
				}

				return file, structType, embeddedStructs, nil
			}
		}
	}
	return nil, nil, nil, fmt.Errorf("(findStructType) struct %s not found", gen.typeName)
}

func (gen *Generator) findEmbeddedStructs(structType *ast.StructType) ([]*ast.StructType, error) {
	var embeddedStructs []*ast.StructType

	for _, field := range structType.Fields.List {
		// Check if it's an embedded field (anonymous field)
		if len(field.Names) == 0 {
			var embeddedTypeName string

			// Get embedded type name
			switch expr := field.Type.(type) {
			case *ast.Ident:
				embeddedTypeName = expr.Name
			case *ast.StarExpr:
				if ident, ok := expr.X.(*ast.Ident); ok {
					embeddedTypeName = ident.Name
				}
			case *ast.SelectorExpr:
				// Handle types from other packages, e.g. otherpkg.Type
				if ident, ok := expr.X.(*ast.Ident); ok {
					embeddedTypeName = ident.Name + "." + expr.Sel.Name
				}
			}

			if embeddedTypeName == "" {
				continue
			}

			// Find struct corresponding to this identifier
			embeddedStruct, err := gen.findStructByName(embeddedTypeName)
			if err != nil {
				gen.logVerbose("warning: cannot find embedded struct %s: %v", embeddedTypeName, err)
				continue
			}

			if embeddedStruct != nil {
				embeddedStructs = append(embeddedStructs, embeddedStruct)

				// Recursively find nested embedded structs
				nestedStructs, err := gen.findEmbeddedStructs(embeddedStruct)
				if err != nil {
					return nil, err
				}
				embeddedStructs = append(embeddedStructs, nestedStructs...)
			}
		}
	}

	return embeddedStructs, nil
}

func (gen *Generator) findStructByName(typeName string) (*ast.StructType, error) {
	// Handle types from other packages
	if strings.Contains(typeName, ".") {
		parts := strings.Split(typeName, ".")
		if len(parts) != 2 {
			return nil, fmt.Errorf("cross-package embedded struct %s not supported", typeName)
		}

		// Simplified handling, may need to load other packages in practice
		gen.logVerbose("warning: cross-package embedded struct %s may not be handled correctly", typeName)
		return nil, nil
	}

	for _, file := range gen.pkg.Syntax {
		for _, decl := range file.Decls {
			genDecl, ok := decl.(*ast.GenDecl)
			if !ok || genDecl.Tok != token.TYPE {
				continue
			}

			for _, spec := range genDecl.Specs {
				typeSpec, ok := spec.(*ast.TypeSpec)
				if !ok || typeSpec.Name.Name != typeName {
					continue
				}

				if structType, ok := typeSpec.Type.(*ast.StructType); ok {
					return structType, nil
				}
			}
		}
	}

	return nil, fmt.Errorf("struct %s not found in package %s", typeName, gen.pkg.Name)
}

func (gen *Generator) generateAtMethod(structType *ast.StructType, embeddedStructs []*ast.StructType) (*jen.Statement, error) {
	method := jen.
		Comment(
			fmt.Sprintf("At updates %s field by key via visit callback", gen.typeName),
		).
		Line().
		Comment("key: field key (tag or lowercase name), visit: processes current value and returns new value").
		Line().
		Func().
		Params(jen.Id("s").Op("*").Id(gen.typeName)).
		Id("At").
		Params(
			jen.Id("key").String(),
			jen.Id("visit").Func().Params(jen.Id("val").Any()).Any(),
		).
		Block(
			jen.Switch(jen.Id("key")).BlockFunc(func(group *jen.Group) {
				processedKeys := make(map[string]bool)
				gen.processStructFields(group, structType, "s", processedKeys)
				for _, embeddedStruct := range embeddedStructs {
					gen.processStructFields(group, embeddedStruct, "s", processedKeys)
				}
				group.Default().Block(jen.Id("visit").Call(jen.Nil()))
			}),
		)

	return method, nil
}

func (gen *Generator) processStructFields(group *jen.Group, structType *ast.StructType, receiver string, processedKeys map[string]bool) {
	for _, field := range structType.Fields.List {
		if len(field.Names) == 0 {
			continue // Skip embedded fields
		}

		fieldName := field.Names[0].Name
		key := gen.getFieldKey(field, fieldName)

		if processedKeys[key] {
			continue
		}
		processedKeys[key] = true

		// 1. Get jennifer type node (for code generation)
		fieldTypeNode := gen.getFieldType(field.Type)
		// 2. Get type string correctly (for checking if it's interface{})
		var fieldTypeStr string
		{
			buf := new(bytes.Buffer)
			if err := fieldTypeNode.Render(buf); err != nil {
				gen.logVerbose("warning: failed to parse field %s type: %v, treating as interface{}", fieldName, err)
				fieldTypeStr = "interface{}"
			} else {
				fieldTypeStr = buf.String()
			}
		}

		// 3. Generate case statement
		group.Case(jen.Lit(key))
		// 4. Call visit function
		group.Id("result").Op(":=").Id("visit").Call(jen.Id(receiver).Dot(fieldName))
		// 5. Type check and assignment
		group.If(jen.Id("result").Op("!=").Nil()).BlockFunc(func(ifGroup *jen.Group) {
			if fieldTypeStr == "interface{}" || fieldTypeStr == "any" {
				ifGroup.Id(receiver).Dot(fieldName).Op("=").Id("result")
			} else {
				ifGroup.If(
					jen.List(jen.Id("newVal"), jen.Id("ok")).Op(":=").
						Id("result").Assert(fieldTypeNode),
					jen.Id("ok"),
				).Block(
					jen.Id(receiver).Dot(fieldName).Op("=").Id("newVal"),
				)
			}
		})
	}
}

func (gen *Generator) getFieldType(expr ast.Expr) *jen.Statement {
	switch t := expr.(type) {
	case *ast.Ident:
		// Local type (current package), use Ident directly
		return jen.Id(t.Name)

	case *ast.StarExpr:
		// Pointer type: *T, process inner type recursively
		return jen.Op("*").Add(gen.getFieldType(t.X))

	case *ast.ArrayType:
		// Slice type: []T (simplified, ignores fixed-length arrays)
		return jen.Index().Add(gen.getFieldType(t.Elt))

	case *ast.MapType:
		// Map type: map[K]V, process Key and Value types separately
		return jen.Map(gen.getFieldType(t.Key)).Add(gen.getFieldType(t.Value))

	case *ast.SelectorExpr:
		// Cross-package type: otherpkg.User (core fix)
		if xIdent, ok := t.X.(*ast.Ident); ok {
			// 1. Find package path corresponding to alias from imports
			var pkgPath string
			for path, alias := range gen.imports {
				if alias == xIdent.Name {
					pkgPath = path
					break
				}
			}
			// 2. If package path found, use Qual for cross-package type
			if pkgPath != "" {
				return jen.Qual(pkgPath, t.Sel.Name)
			}
		}
		// Fallback: use Selector if package path not found
		return gen.getFieldType(t.X).Dot(t.Sel.Name)

	case *ast.InterfaceType:
		// Interface type: interface{}
		return jen.Interface()

	case *ast.StructType:
		// Anonymous struct: struct{}
		return jen.Struct()

	default:
		gen.logVerbose("warning: unknown type %T, using any", t)
		return jen.Any()
	}
}

func (gen *Generator) getFieldKey(field *ast.Field, fieldName string) string {
	// If key type is specified (json/yaml/xml), use corresponding tag first
	if gen.keyType != "field" && field.Tag != nil {
		tag := strings.Trim(field.Tag.Value, "`")
		tagValue := extractTagValue(tag, gen.keyType)

		// Handle cases like `json:",omitempty"`
		if tagValue == "," {
			return strings.ToLower(fieldName)
		}
		parts := strings.SplitN(tagValue, ",", 2)
		if parts[0] != "" {
			return parts[0]
		}
	}

	// Use lowercase field name if no specified tag found
	return strings.ToLower(fieldName)
}

// Extract value for specified key from tag string
func extractTagValue(tag, key string) string {
	st := reflect.StructTag(strings.Trim(tag, "`"))
	return st.Get(key)
}
